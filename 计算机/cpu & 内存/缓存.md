# CPU缓存

## 简介

### 相关博客

> [cpu 缓存 csdn 简单介绍](https://blog.csdn.net/dongyanxia1000/article/details/53392315)

> [cpu 缓存 知乎大体描述](https://zhuanlan.zhihu.com/p/37749443)

> [华为云 cpu 缓存 ](https://www.huaweicloud.com/zhishi/arc-9558555.html)

> [华为云cpu 缓存详解](https://www.huaweicloud.com/articles/153d815452a348f8da988d6dca37b9a2.html)

### 自己的话描述

首先，Cpu 缓存，是指L1 Cache，L2 Cache。

由于成本过高，所以该资源较为珍惜，现用作缓存使用。

CPU 缓存还需要额外考虑一件事情，核心1修改的数据不会立刻同步到内存中，而是会先同步到L1 L2 L3中。在同步的过程中，或者说是在修改的过程中，我们如何保证数据的一致性呢？（MESI等）



既然cache 用来做缓存，那就得有相应的映射表，就像redis ，他再缓存时是需要一定的对应关系的。我们通常直接使用`set name redis` `get name redis` 进行映射。这中间的 name ，就可以说是一个索引。



说回CPU缓存，从实现的角度有3种模式

1. **直接映射高速缓存**
2. **全相联高速缓存**
3. **组相联高速缓存**



#### 直接映射高速缓存

就代表我通过一定方式，直接将数据一一对应。



> 假设某台计算机**主存容量**为1MB，被分为**2048**块，每个Block为512B；Cache容量为8KB，被分为**16**块，每块也是512B。



在内存中的地址映射过来是固定的，每条数据的位置都是固定的，可以快速的通过内存地址找到对应的 Cache地址。



##### 实现方式:

主要思路为，让16块的缓存映射出2048块

- hashmap 思路，直接对地址% `2048%16`
- 单行对应大量地址，`2048/16`为一行代表数。
  - 第一行的映射为 0~128
  - 第二行的映射为 128~256
  - ...



#### 全相联映射

主存中的一个地址可以被任意的映射进缓存位置。



当我们需要获取内存地址时，我们先遍历一遍cache，看看有没有我们所需要的地址，如果有，则取出。如果没有则去内存重新查找后填入。



##### 实现方式：

- 遍历



#### 组相联映射

利用二者优点

- 直接映射可快速查找。
- 全相联映射可将缓存利用最大号。

##### 简单描述

>  组相联映射实际上是直接映射和全相联映射的折中方案。**主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射**。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的。

> 例如，主存分为256组，每组8块，Cache分为8组，每组2块。

>  **Cache中的分组数相同，组间采用直接映射，组内采用全相联映射**。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的。例如，主存分为256组，每组8块，Cache分为8组，每组2块。

##### 实现思路

- 先对整体的内存进行分组，分成一个合适的值，组内就让Cpu进行遍历。
  - 增加了直接映射的命中概率
  - 减少了全相联映射的遍历次数

![Cache直接映射、组相连映射以及全相连映射（转载）7](490550cf4c2945a2aa49b87f3052ac371603441956721)
