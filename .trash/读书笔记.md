# 读书笔记



## Go优化

优化的方式如下

- 减少内存分配
- 利用逃逸分析
- 减少内存复制
- 减少指针
- 减少边界检查 BCE
- Goroutine扩容
- 降低GC压力
- 通过类型或者结构体字段区分，减少`channel`分支

### 内存分配

介绍完了堆与栈，接下来我们就介绍导致分配的操作。

- 申明变量
- 调用内置的`new`方法
- 调用内置的`make`方法
- 使用复合文字修改切片和映射。
- 转换int到string
- 使用`+`连接字符串
- 转换`string`到`[]byte`
- 转换`string`到`rune`
- `interface`装箱（非`interface`值到`interface`）
- 添加元素到`slice`或`map`时超出其容量

一般在以上几种都会产生内存分配，可能是堆，可能是栈。具体的分配，我们就得根据逃逸分析来进行决定。

#### 小技巧

内存分配的小技巧

- 如果我们有许多零散并且生命周期相同的变量，我们不如一次性给他分配完毕
- 利用享元模式（缓存池）避免大量小对象的创建和回收。
- 给`slice` `map` 一次分配足够的容量

### 内存复制

Go有对小对象（一般定义为`4 native-word-size`）的内存复制操作进行优化，他们的复制操作通常都非常快。

- 装箱操作
- 参数传递和返回值
- 从`channel`接收和发送
- 添加元素到`map`中
- 添加元素到`slice`中
- 通过`for-range`的第二个参数。

我们应当尽量避免大对象的复制来提升性能。

#### 内存复制的小技巧

- 我们可以将大对象变成指针，来减少复制带来的成本。
- 不要使用`for-range`的第二个参数

### 逃逸分析

逃逸分析，就是用于分析变量应该在堆上，还是应该分配在栈上的东西。

- 在有两个`goroutine`同时访问统一变量，同时有一个`goroutine`修改了变量
  - 因为栈内存无法被共享。
- 循环中可能出现逃逸
  - 因为编译器无法确保他是唯一的一个实例。（循环生成多个实例，然后赋值到上面某个实例中。）
- `interface`调用参数方法时，参数逃逸
  - 由于编译器无法确定`interface`的实现中是否会发生逃逸，所以将分配到堆。
- 反射时
  - ``reflect.ValueOf`
- 方法返回变量时
- 内联方法可能会导致原本逃逸的方法不再逃逸。
- 值过大进行逃逸
  - 切片 64K 
  - 数组，单独结构体 10M
- `string-to-byte`时
  - 超过32个`byte`，将会逃逸到堆

### go gc

gc触发条件如下

- 在堆内存扩大至原先的200%时
- 每2分钟

#### 减少gc压力的方式

分为两个部分：

- 减少分配短寿命的内存区域（垃圾产生速度）
- 减少指针（扫描工作压力）

通常分配在堆上的变量，他的隐式指针是存放在栈上，以引向已分配在堆上的变量，以便可以跟踪该值部分。（当然，堆内的变量也可以互相引用）

同时，我们不需要刻意的避免使用指针，毕竟指针通常可以用于减少内存`copy`。

#### 减少gc触发次数

默认的GC触发时间是堆增长到上一次GC结束时堆大小的`100+GOGC`，在默认情况下就是下次GC时，堆大小是当前堆的1倍

所以我们可以通过调高GC阈值来进行调整

也可以使用 twitch 的小技巧

```go
func main() {
    // ballastSize is value much larger than the
    // maximum possible live heap size of the program.
    ballast := make([]byte, ballastSize)
    programRun() // never exit
	runtime.KeepAlive(&ballast) 
}
```

但由于该元素从来没被使用过，所以他只是虚拟分配，并没有实际占用内存。（至少在 Linux上）

### 边界检查

我们在使用切片时，通常需要避免使用到其他变量的内存块，我们如何保证呢？这里就是Go通过边界检查来实现相关功能。但由于Go的边界检查不够聪明，我们需要做一些额外的暗示，去让他明白一些边界检查是不必要的。

#### 小技巧

- 通常我们可以利用切片切割的方式来暗示。
- 

### goroutine扩容

`goroutine`默认是 2KiB，他是幂等增长的，最小为2KiB。

当`goroutine`所需要的栈空间超过了2KiB 他将会发生扩容，在扩容时，会将老栈上，**正在使用的变量复制到新的栈区**。栈大小在64位上，最大为1GB(不是GiB)。

当`goroutine`在垃圾回收期中，发现该栈空间过大，并不需要那么大时，并且没有做任何事情，或处于系统调用 or cgo 调用时，将会进行收缩。同时每次GC只会收缩一半。

#### 小技巧

在某些情况下，你能知道并且百分百预测栈需要被扩容，那么，我们可以在该方法中添加一个匿名方法，该方法用于扩容栈。避免重复扩容。

```go
func(x *interface{}) {
    type _ int // avoid being inlined
    if x != nil {
    	*x = [1024 * 1024 * 64]byte{}// 预测栈大小值
    }
}(nil)
```



### 方法

内联方法一般效率会高点，因为不用额外的栈空间，但也会附带来一定的问题，比如让生成的二进制文件更大。

#### 小技巧

- 手动内联比自动内联性能更高

- 我们应该尽量让热路径代码内联

- 在参数较大时，为了避免复制成本过高，使用指针参数

- 一般命名返回值的性能比不命名返回值要高一点

- 尽量将中间结果保存在本地变量中。

- 避免在循环中使用defer

- 减少使用defer

- 减少方法参数的一个检测或复制

  - ```go
    debugOn && debugPrint(h+w)
    ```

- 减少热路径代码逃逸到堆

- 尝试使用`switch`处理热路径分支

### interface

#### 小技巧

- 装箱时，指针变量快于非指针变量
  - 指针最快
- 装箱`map` `channel` `function` 速度类似于指针存放
  - 与指针相同
- 装箱零值，布尔值和8bit 的int值类似于装箱指针。
  - 与指针相同
- 装箱常量类似于指针。
  - 与指针相同
- 装箱非常量的小值
  - 性能低于指针装箱三倍
- 装箱浮点值和字符串零值
  - 性能低于指针装箱三倍
- 单结构体字段类型，并且类型为零值浮点或空字符串时
  - 性能低于指针装箱三倍
- 非常量值大于int8，不是零值的浮点数
  - 性能低于指针20倍
- 装箱切片或不是空字符串
  - 性能至少低于50倍



## Go实用编译参数

### 参数

- `-gcflag=""`
  - `-m` 逃逸分析
  - `-m -m` 可查看相应内联方法代价
  - `-smallframes` 小框架模式，将64K与10M限制改为，16K与128K
  - `-d=ssa/check_bce/debug=1` 边界检查
- `-gcflag=""`
  - `-B` 禁用越界检查
  - `-N` 禁用优化
  - `-l` 禁用内联
  - `-u` 禁用 unsafe
  - `-S` 输出汇编代码
  - `-m` 输出优化信息



### 环境变量

[环境变量介绍](https://pkg.go.dev/runtime#hdr-Environment_Variables)

- `GOGC`
  - go GC的百分比
- `GODEBUG=gctrace=1`
  - 开启GC跟踪
- 

### 测试



#### 代码覆盖率

- `go test -cover`
- `go test -cover -coevermode count -coverprofile cover.out`

#### 性能监控

```shell
go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net/http
```

```shell
go tool pprof http.test mem.out
```

```shell
top5
```

在这里我们可以看到

- flag：当前函数内存开销（不包括它调用的函数）
- sum：列表前几行所占百分比的总和
- cum：当前函数的堆栈累计（包括它调用的函数）



```shell
peek malg
```

peek 命令，用于列出调用来源



```shell
list malg
```

可以通过list命令更直观的定位



```shell
web
```

```shell
web malg
```

还可生成svg图形