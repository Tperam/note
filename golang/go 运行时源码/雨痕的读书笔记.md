# 实操记录

## 准备

```shell
$ go version
go version go1.5.1 linux/amd64
```

```shell
$ lsb_release -d
Description:    Ubuntu 20.04.3 LTS
```

```shell
$ gdb --version
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
```

## 引导

test.go

```go
package main

func main (){
        println("hello, world!")
}
```

```shell
go build -gcflags "-N -l" -o test test.go
```

使用gdb查看

```shell
$ gdb test
```

```shell
(gdb) info files
Symbols from "/home/tperam/tmp/test".
Local exec file:
        `/home/tperam/tmp/test', file type elf64-x86-64.
        Entry point: 0x44dcf0
        0x0000000000401000 - 0x000000000044e220 is .text
        0x000000000044f000 - 0x000000000048a4cb is .rodata
        0x000000000048a4d0 - 0x000000000048ad80 is .typelink
        0x000000000048ad80 - 0x000000000048ad80 is .gosymtab
        0x000000000048ad80 - 0x00000000004b0648 is .gopclntab
        0x00000000004b1000 - 0x00000000004b1310 is .noptrdata
        0x00000000004b1320 - 0x00000000004b1dd8 is .data
        0x00000000004b1de0 - 0x00000000004d5618 is .bss
        0x00000000004d5620 - 0x00000000004d9d40 is .noptrbss
        0x0000000000400fc8 - 0x0000000000401000 is .note.go.buildid
```

```shell
(gdb) b *0x44dcf0
Breakpoint 1 at 0x44dcf0: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.
```

然后，从这里我们就能看到，我们文件的开始位置是在 `/usr/local/go/src/runtime/rt0_linux_amd64.s`，但由于我们用了`gvm`（版本管理器），所以实际路径如下`/home/tperam/.gvm/gos/go1.5.1/`

打开后是这样

```assembly
TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	LEAQ	8(SP), SI // argv
	MOVQ	0(SP), DI // argc
	MOVQ	$main(SB), AX
	JMP	AX
	
TEXT main(SB),NOSPLIT,$-8
	MOVQ	$runtime·rt0_go(SB), AX
	JMP	AX
```

我们可以从上面代码中看到

- `MOVQ $main(SB),AX`

然后在`TEXT main(SB),NOSPLIT,$-8`方法中，看到

- `MOVQ	$runtime·rt0_go(SB), AX`

这里可能算是调用方法（暂时这么理解），根据书本上的操作，去给该方法设置断点

```shell
(gdb) b runtime.rt0_go
Breakpoint 2 at 0x44a770: file /usr/local/go/src/runtime/asm_amd64.s, line 12.
```

这段汇编代码就是你真正要找的目标，正是它完成了初始化和运行时启动。

asm_amd64.s

```assembly
TEXT runtime·rt0_go(SB),NOSPLIT,$0
	// copy arguments forward on an even stack
	MOVQ	DI, AX		// argc
	MOVQ	SI, BX		// argv
	SUBQ	$(4*8+7), SP		// 2args 2auto
	ANDQ	$~15, SP
	MOVQ	AX, 16(SP)
	MOVQ	BX, 24(SP)
	
	// create istack out of the given (operating system) stack.
	// _cgo_init may update stackguard.
	MOVQ	$runtime·g0(SB), DI
	LEAQ	(-64*1024+104)(SP), BX
	MOVQ	BX, g_stackguard0(DI)
	MOVQ	BX, g_stackguard1(DI)
	MOVQ	BX, (g_stack+stack_lo)(DI)
	MOVQ	SP, (g_stack+stack_hi)(DI)

	// find out information about the processor we're on
	MOVQ	$0, AX
	CPUID
	CMPQ	AX, $0
	JE	nocpuinfo

	// Figure out how to serialize RDTSC.
	// On Intel processors LFENCE is enough. AMD requires MFENCE.
	// Don't know about the rest, so let's do MFENCE.
	CMPL	BX, $0x756E6547  // "Genu"
	JNE	notintel
	CMPL	DX, $0x49656E69  // "ineI"
	JNE	notintel
	CMPL	CX, $0x6C65746E  // "ntel"
	JNE	notintel
	MOVB	$1, runtime·lfenceBeforeRdtsc(SB)
notintel:

	MOVQ	$1, AX
	CPUID
	MOVL	CX, runtime·cpuid_ecx(SB)
	MOVL	DX, runtime·cpuid_edx(SB)
nocpuinfo:	
	
	// if there is an _cgo_init, call it.
	MOVQ	_cgo_init(SB), AX
	TESTQ	AX, AX
	JZ	needtls
	// g0 already in DI
	MOVQ	DI, CX	// Win64 uses CX for first parameter
	MOVQ	$setg_gcc<>(SB), SI
	CALL	AX

	// update stackguard after _cgo_init
	MOVQ	$runtime·g0(SB), CX
	MOVQ	(g_stack+stack_lo)(CX), AX
	ADDQ	$const__StackGuard, AX
	MOVQ	AX, g_stackguard0(CX)
	MOVQ	AX, g_stackguard1(CX)

	CMPL	runtime·iswindows(SB), $0
	JEQ ok
needtls:
	// skip TLS setup on Plan 9
	CMPL	runtime·isplan9(SB), $1
	JEQ ok
	// skip TLS setup on Solaris
	CMPL	runtime·issolaris(SB), $1
	JEQ ok

	LEAQ	runtime·tls0(SB), DI
	CALL	runtime·settls(SB)

	// store through it, to make sure it works
	get_tls(BX)
	MOVQ	$0x123, g(BX)
	MOVQ	runtime·tls0(SB), AX
	CMPQ	AX, $0x123
	JEQ 2(PC)
	MOVL	AX, 0	// abort
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAQ	runtime·g0(SB), CX
	MOVQ	CX, g(BX)
	LEAQ	runtime·m0(SB), AX

	// save m->g0 = g0
	MOVQ	CX, m_g0(AX)
	// save m0 to g0->m
	MOVQ	AX, g_m(CX)

	CLD				// convention is D is always left cleared
	CALL	runtime·check(SB)

	MOVL	16(SP), AX		// copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX		// copy argv
	MOVQ	AX, 8(SP)
	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB)
	CALL	runtime·schedinit(SB)

	// create a new goroutine to start program
	MOVQ	$runtime·mainPC(SB), AX		// entry
	PUSHQ	AX
	PUSHQ	$0			// arg size
	CALL	runtime·newproc(SB)
	POPQ	AX
	POPQ	AX

	// start this M
	CALL	runtime·mstart(SB)

	MOVL	$0xf1, 0xf1  // crash
	RET

DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)
GLOBL	runtime·mainPC(SB),RODATA,$8
```

至此，汇编语言针对特定平台实现的引导过程就全部完成。后续内容基本上都是由Go代码实现的。

```shell
(gdb) b runtime.main
Breakpoint 3 at 0x423240: file /usr/local/go/src/runtime/proc.go, line 28.
```

## 初始化

初始化过程相当繁琐，要完成

- 注入命令行参数整理
- 环境变量设置
- 内存分配器
- 垃圾回收器
- 并发调度器

的工作现场准备。

根据14章找出的线索，先一次看看几个初始化函数的内容。依旧用设置断点命令确定函数所在的原文件名和代码行号

```shell
(gdb) b runtime.args
Breakpoint 4 at 0x42ebe0: file /usr/local/go/src/runtime/runtime1.go, line 48.

(gdb) b runtime.osinit
Breakpoint 5 at 0x41e9c0: file /usr/local/go/src/runtime/os1_linux.go, line 172.

(gdb) b runtime.schedinit
Breakpoint 6 at 0x424580: file /usr/local/go/src/runtime/proc1.go, line 40.
```

runtime1.go

```go
func args(c int32, v **byte) {
	argc = c
	argv = v
	sysargs(c, v)
}
```



用于确定CPU Core数量

osl_linux.go

```go
func osinit() {
	ncpu = getproccount()
}
```



最关键的就是`schedinit`这里，几乎我们要关注的所有运行时环境初始化构造都是在这里被调用的。函数头部的注释列举了启动过程，也就是第14章的内容，不过信息太过简介了。

proc1.go

```go
func schedinit() {
	// raceinit must be the first call to race detector.
	// In particular, it must be done before mallocinit below calls racemapshadow.
	_g_ := getg()
	if raceenabled {
		_g_.racectx = raceinit()
	}
	// 最大系统线程数量限制，参考标准库 runtime/debug.SetMaxThreads
	sched.maxmcount = 10000

	// Cache the framepointer experiment.  This affects stack unwinding.
	framepointer_enabled = haveexperiment("framepointer")

	tracebackinit()
	moduledataverify()
    
    // 栈、内存分配器、调度器相关初始化
	stackinit()
	mallocinit()
	mcommoninit(_g_.m)

    // 处理命令
	goargs()
	goenvs()
    
    // 处理 GODEBUG、GOTRACEBACK 调试相关的环境变量设置
	parsedebugvars()
    
    // 垃圾回收器初始化
	gcinit()

	sched.lastpoll = uint64(nanotime())
    
    // 通过 CPU Core 和 GOMAXPROCS 环境变量确定P数量
	procs := int(ncpu)
	if n := atoi(gogetenv("GOMAXPROCS")); n > 0 {
		if n > _MaxGomaxprocs {
			n = _MaxGomaxprocs
		}
		procs = n
	}
    // 调整P数量
	if procresize(int32(procs)) != nil {
		throw("unknown runnable goroutine during bootstrap")
	}

	if buildVersion == "" {
		// Condition should never trigger.  This code just serves
		// to ensure runtime·buildVersion is kept in the resulting binary.
		buildVersion = "unknown"
	}
}
```

内存分配器、垃圾回收器、并发调度器的初始化细节先跳过

事实上，初始化操作到此并未结束，因为接下来要执行的是`runtime.main`，而不是用户逻辑入口的`main.main`

```shell
(gdb) b runtime.main
Note: breakpoint 3 also set at pc 0x423240.
Breakpoint 7 at 0x423240: file /usr/local/go/src/runtime/proc.go, line 28.
```

根据上述信息，我们找到 `runtime.proc.go`文件

```go
// The main goroutine.
func main() {
	g := getg()

	// Racectx of m0->g0 is used only as the parent of the main goroutine.
	// It must not be used for anything else.
	g.m.g0.racectx = 0

	// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
	// Using decimal instead of binary GB and MB because
	// they look nicer in the stack overflow failure message.
	if ptrSize == 8 {
		maxstacksize = 1000000000
	} else {
		maxstacksize = 250000000
	}

	// Record when the world started.
	runtimeInitTime = nanotime()

    // 启动系统监控（定期垃圾回收，以及并发任务调度相关的信息）
	systemstack(func() {
		newm(sysmon, nil)
	})

	// Lock the main goroutine onto this, the main OS thread,
	// during initialization.  Most programs won't care, but a few
	// do require certain calls to be made by the main thread.
	// Those can arrange for main.main to run in the main thread
	// by calling runtime.LockOSThread during initialization
	// to preserve the lock.
	lockOSThread()

	if g.m != &m0 {
		throw("runtime.main not on m0")
	}

	runtime_init() // must be before defer

	// Defer unlock so that runtime.Goexit during init does the unlock too.
	needUnlock := true
	defer func() {
		if needUnlock {
			unlockOSThread()
		}
	}()

	gcenable()

	main_init_done = make(chan bool)
	if iscgo {
		if _cgo_thread_start == nil {
			throw("_cgo_thread_start missing")
		}
		if _cgo_malloc == nil {
			throw("_cgo_malloc missing")
		}
		if _cgo_free == nil {
			throw("_cgo_free missing")
		}
		if GOOS != "windows" {
			if _cgo_setenv == nil {
				throw("_cgo_setenv missing")
			}
			if _cgo_unsetenv == nil {
				throw("_cgo_unsetenv missing")
			}
		}
		if _cgo_notify_runtime_init_done == nil {
			throw("_cgo_notify_runtime_init_done missing")
		}
		cgocall(_cgo_notify_runtime_init_done, nil)
	}

	main_init()
	close(main_init_done)

	needUnlock = false
	unlockOSThread()

	if isarchive || islibrary {
		// A program compiled with -buildmode=c-archive or c-shared
		// has a main, but it is not executed.
		return
	}
	main_main()
	if raceenabled {
		racefini()
	}

	// Make racy client program work: if panicking on
	// another goroutine at the same time as main returns,
	// let the other goroutine finish printing the panic trace.
	// Once it does, it will exit. See issue 3934.
	if panicking != 0 {
		gopark(nil, nil, "panicwait", traceEvGoStop, 1)
	}

	exit(0)
	for {
		var x *int32
		*x = 0
	}
}
```

